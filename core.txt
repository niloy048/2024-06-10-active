import time
import os
import re
import threading
import requests
import queue
import datetime
from flask import Flask
from bs4 import BeautifulSoup
from urllib.parse import urljoin

# ============================================================
# ğŸŒ GLOBAL CONFIG (No Logic Change)
# ============================================================

BOT_NAME = os.environ.get("BOT_NAME", "Ims Master Bot")
BOT_TOKEN = os.environ.get("BOT_TOKEN", "")
ADMIN_IDS = os.environ.get("ADMIN_IDS", "").split(",")
TARGET_GROUP_ID = "-1003692783602" 

LOGIN_URL = os.environ.get("LOGIN_URL", "")
OTP_URL = os.environ.get("OTP_URL", "")
LOGIN_HEADERS_ENV = os.environ.get("LOGIN_HEADERS", "")
PANEL_USER = os.environ.get("PANEL_USER", "")
PANEL_PASS = os.environ.get("PANEL_PASS", "")

# Mapping from Env
COL_MAP = [int(i)-1 for i in os.environ.get("COL_MAPPING", "1,2,3,6").split(",")]
CHECK_DELAY = float(os.environ.get("CHECK_DELAY", 1.0))

IS_FIRST_RUN = True
OTP_QUEUE = queue.Queue()
PROCESSED_OTP_CACHE = set()
CACHE_LOCK = threading.Lock()

threads_status = {"collector": None, "sender": None}

app = Flask(__name__)

@app.route('/')
def home():
    return f"ğŸ¦… {BOT_NAME} Status: Ultra-Speed Sniper Active"

# ============================================================
# âš¡ à¦¸à§à¦®à¦¾à¦°à§à¦Ÿ à¦‡à¦‰à¦Ÿà¦¿à¦²à¦¿à¦Ÿà¦¿
# ============================================================

def mask_phone(phone):
    if not phone or len(phone) < 7:
        return phone
    return f"{phone[:-7]}***{phone[-4:]}"

def memory_cleaner():
    global PROCESSED_OTP_CACHE
    while True:
        time.sleep(86400) 
        with CACHE_LOCK:
            PROCESSED_OTP_CACHE.clear()
            send_admin_log("ğŸ§¹ Memory Cleared Successfully.")

# ============================================================
# ğŸ“¨ TELEGRAM WORKER (Format Updated to Match Image)
# ============================================================

def telegram_worker():
    """ à¦Ÿà§‡à¦²à¦¿à¦—à§à¦°à¦¾à¦® à¦¸à§‡à¦¨à§à¦¡à¦¾à¦° à¦¥à§à¦°à§‡à¦¡ - à¦›à¦¬à¦¿ à¦…à¦¨à§à¦¯à¦¾à§Ÿà§€ à¦¹à§à¦¬à¦¹à§ à¦«à¦°à¦®à§à¦¯à¦¾à¦Ÿ """
    tg_session = requests.Session()
    while True:
        try:
            msg_data = OTP_QUEUE.get()
            if msg_data is None: break
            
            phone, country, service, otp, full_msg = msg_data
            masked_number = mask_phone(phone)
            
            # --- Bangladesh Time (UTC + 6) ---
            now_utc = datetime.datetime.utcnow()
            bd_time = now_utc + datetime.timedelta(hours=6)
            formatted_time = bd_time.strftime('%Y-%m-%d %H:%M:%S')
            
            # --- New Message Format based on Image ---
            formatted_text = (
                f"âœ… {country} | {service} OTP Received\n"
                f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
                f"ğŸ“± <b>Number:</b> {masked_number}\n"
                f"ğŸ”‘ <b>OTP Code:</b> {otp}\n"
                f"ğŸ›  <b>Service:</b> {service}\n"
                f"ğŸŒ <b>Country:</b> {country}\n"
                f"â° <b>Time:</b> {formatted_time}\n\n"
                f"ğŸ’¬ <b>Message:</b>\n"
                f"<blockquote>{full_msg}</blockquote>"
            )
            
            url = f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage"
            
            # Payload with No Buttons
            payload = {
                "chat_id": TARGET_GROUP_ID, 
                "text": formatted_text, 
                "parse_mode": "HTML"
            }
            
            while True:
                res = tg_session.post(url, json=payload, timeout=10)
                if res.status_code == 429:
                    retry_after = res.json().get('parameters', {}).get('retry_after', 3)
                    time.sleep(retry_after)
                    continue
                break
            
            time.sleep(0.5)
            OTP_QUEUE.task_done()
        except Exception:
            time.sleep(1)

# ============================================================
# ğŸ›  à¦…à§à¦¯à¦¾à¦¡à¦®à¦¿à¦¨ à¦²à¦— à¦“ à¦‡à¦à§à¦œà¦¿à¦¨ à¦Ÿà§à¦²à¦¸
# ============================================================

def send_telegram(msg, parse_mode="HTML"):
    url = f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage"
    for admin in ADMIN_IDS:
        try: requests.post(url, json={"chat_id": admin, "text": msg, "parse_mode": parse_mode}, timeout=10)
        except: pass

def send_admin_log(msg):
    # BD Time for System Log
    now_utc = datetime.datetime.utcnow()
    bd_time = now_utc + datetime.timedelta(hours=6)
    t_str = bd_time.strftime('%H:%M:%S')
    
    formatted_msg = f"ğŸ›° <b>{BOT_NAME} SYSTEM LOG</b>\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n{msg}\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nğŸ•’ {t_str}"
    send_telegram(formatted_msg)

def send_error_telegram(action_failed, reason, target):
    msg = (
        f"ğŸ›‘ <b>{BOT_NAME} - SYSTEM ALERT</b> ğŸ›‘\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        f"âŒ <b>Action Failed:</b> <code>{action_failed}</code>\n"
        f"ğŸ“ <b>Target:</b> <code>{target}</code>\n"
        f"âš ï¸ <b>Reason:</b> <i>{reason}</i>\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        f"ğŸ•’ {time.strftime('%H:%M:%S')}"
    )
    send_telegram(msg)

COUNTRY_EMOJIS = {
"Afghanistan": "ğŸ‡¦ğŸ‡«", "Albania": "ğŸ‡¦ğŸ‡±", "Algeria": "ğŸ‡©ğŸ‡¿", "Andorra": "ğŸ‡¦ğŸ‡©", "Angola": "ğŸ‡¦ğŸ‡´", "Antigua and Barbuda": "ğŸ‡¦ğŸ‡¬", "Argentina": "ğŸ‡¦ğŸ‡·", "Armenia": "ğŸ‡¦ğŸ‡²", "Australia": "ğŸ‡¦ğŸ‡º", "Austria": "ğŸ‡¦ğŸ‡¹", "Azerbaijan": "ğŸ‡¦ğŸ‡¿",
"Bahamas": "ğŸ‡§ğŸ‡¸", "Bahrain": "ğŸ‡§ğŸ‡­", "Bangladesh": "ğŸ‡§ğŸ‡©", "Barbados": "ğŸ‡§ğŸ‡§", "Belarus": "ğŸ‡§ğŸ‡¾", "Belgium": "ğŸ‡§ğŸ‡ª", "Belize": "ğŸ‡§ğŸ‡¿", "Benin": "ğŸ‡§ğŸ‡¯", "Bhutan": "ğŸ‡§ğŸ‡¹", "Bolivia": "ğŸ‡§ğŸ‡´", "Bosnia": "ğŸ‡§ğŸ‡¦", "Botswana": "ğŸ‡§ğŸ‡¼", "Brazil": "ğŸ‡§ğŸ‡·", "Brunei": "ğŸ‡§ğŸ‡³", "Bulgaria": "ğŸ‡§ğŸ‡¬", "Burkina": "ğŸ‡§ğŸ‡«", "Burundi": "ğŸ‡§ğŸ‡®",
"Cabo Verde": "ğŸ‡¨ğŸ‡»", "Cambodia": "ğŸ‡°ğŸ‡­", "Cameroon": "ğŸ‡¨ğŸ‡²", "Canada": "ğŸ‡¨ğŸ‡¦", "Central African Republic": "ğŸ‡¨ğŸ‡«", "Chad": "ğŸ‡¹ğŸ‡©", "Chile": "ğŸ‡¨ğŸ‡±", "China": "ğŸ‡¨ğŸ‡³", "Colombia": "ğŸ‡¨ğŸ‡´", "Comoros": "ğŸ‡°ğŸ‡²", "Congo": "ğŸ‡¨ğŸ‡¬", "DR Congo": "ğŸ‡¨ğŸ‡©", "Costa Rica": "ğŸ‡¨ğŸ‡·", "Croatia": "ğŸ‡­ğŸ‡·", "Cuba": "ğŸ‡¨ğŸ‡º", "Cyprus": "ğŸ‡¨ğŸ‡¾", "Czech": "ğŸ‡¨ğŸ‡¿",
"Denmark": "ğŸ‡©ğŸ‡°", "Djibouti": "ğŸ‡©ğŸ‡¯", "Dominica": "ğŸ‡©ğŸ‡²", "Dominican Republic": "ğŸ‡©ğŸ‡´", "East Timor": "ğŸ‡¹ğŸ‡±", "Ecuador": "ğŸ‡ªğŸ‡¨", "Egypt": "ğŸ‡ªğŸ‡¬", "El Salvador": "ğŸ‡¸ğŸ‡»", "Equatorial Guinea": "ğŸ‡¬ğŸ‡¶", "Eritrea": "ğŸ‡ªğŸ‡·", "Estonia": "ğŸ‡ªğŸ‡ª", "Eswatini": "ğŸ‡¸ğŸ‡¿", "Ethiopia": "ğŸ‡ªğŸ‡¹",
"Fiji": "ğŸ‡«ğŸ‡¯", "Finland": "ğŸ‡«ğŸ‡®", "France": "ğŸ‡«ğŸ‡·", "Gabon": "ğŸ‡¬ğŸ‡¦", "Gambia": "ğŸ‡¬ğŸ‡²", "Georgia": "ğŸ‡¬ğŸ‡ª", "Germany": "ğŸ‡©ğŸ‡ª", "Ghana": "ğŸ‡¬ğŸ‡­", "Greece": "ğŸ‡¬ğŸ‡·", "Grenada": "ğŸ‡¬ğŸ‡©", "Guatemala": "ğŸ‡¬ğŸ‡¹", "Guinea": "ğŸ‡¬ğŸ‡³", "Guinea-Bissau": "ğŸ‡¬ğŸ‡¼", "Guyana": "ğŸ‡¬ğŸ‡¾",
"Haiti": "ğŸ‡­ğŸ‡¹", "Honduras": "ğŸ‡­ğŸ‡³", "Hong Kong": "ğŸ‡­ğŸ‡°", "Hungary": "ğŸ‡­ğŸ‡º", "Iceland": "ğŸ‡®ğŸ‡¸", "India": "ğŸ‡®ğŸ‡³", "Indonesia": "ğŸ‡®ğŸ‡©", "Iran": "ğŸ‡®ğŸ‡·", "Iraq": "ğŸ‡®ğŸ‡¶", "Ireland": "ğŸ‡®ğŸ‡ª", "Israel": "ğŸ‡®ğŸ‡±", "Italy": "ğŸ‡®ğŸ‡¹", "Ivory Coast": "ğŸ‡¨ğŸ‡®",
"Jamaica": "ğŸ‡¯ğŸ‡²", "Japan": "ğŸ‡¯ğŸ‡µ", "Jordan": "ğŸ‡¯ğŸ‡´", "Kazakhstan": "ğŸ‡°ğŸ‡¿", "Kenya": "ğŸ‡°ğŸ‡ª", "Kiribati": "ğŸ‡°ğŸ‡®", "Kosovo": "ğŸ‡½ğŸ‡°", "Kuwait": "ğŸ‡°ğŸ‡¼", "Kyrgyzstan": "ğŸ‡°ğŸ‡¬", "Laos": "ğŸ‡±ğŸ‡¦", "Latvia": "ğŸ‡±ğŸ‡»", "Lebanon": "ğŸ‡±ğŸ‡§", "Lesotho": "ğŸ‡±ğŸ‡¸", "Liberia": "ğŸ‡±ğŸ‡·", "Libya": "ğŸ‡±ğŸ‡¾", "Liechtenstein": "ğŸ‡±ğŸ‡®", "Lithuania": "ğŸ‡±ğŸ‡¹", "Luxembourg": "ğŸ‡±ğŸ‡º",
"Macau": "ğŸ‡²ğŸ‡´", "Madagascar": "ğŸ‡²ğŸ‡¬", "Malawi": "ğŸ‡²ğŸ‡¼", "Malaysia": "ğŸ‡²ğŸ‡¾", "Maldives": "ğŸ‡²ğŸ‡»", "Mali": "ğŸ‡²ğŸ‡±", "Malta": "ğŸ‡²ğŸ‡¹", "Marshall Islands": "ğŸ‡²ğŸ‡­", "Mauritania": "ğŸ‡²ğŸ‡·", "Mauritius": "ğŸ‡²ğŸ‡º", "Mexico": "ğŸ‡²ğŸ‡½", "Micronesia": "ğŸ‡«ğŸ‡²", "Moldova": "ğŸ‡²ğŸ‡©", "Monaco": "ğŸ‡²ğŸ‡¨", "Mongolia": "ğŸ‡²ğŸ‡³", "Montenegro": "ğŸ‡²ğŸ‡ª", "Morocco": "ğŸ‡²ğŸ‡¦", "Mozambique": "ğŸ‡²ğŸ‡¿", "Myanmar": "ğŸ‡²ğŸ‡²",
"Namibia": "ğŸ‡³ğŸ‡¦", "Nauru": "ğŸ‡³ğŸ‡·", "Nepal": "ğŸ‡³ğŸ‡µ", "Netherlands": "ğŸ‡³ğŸ‡±", "New Zealand": "ğŸ‡³ğŸ‡¿", "Nicaragua": "ğŸ‡³ğŸ‡®", "Niger": "ğŸ‡³ğŸ‡ª", "Nigeria": "ğŸ‡³ğŸ‡¬", "North Korea": "ğŸ‡°ğŸ‡µ", "North Macedonia": "ğŸ‡²ğŸ‡°", "Norway": "ğŸ‡³ğŸ‡´", "Oman": "ğŸ‡´ğŸ‡²",
"Pakistan": "ğŸ‡µğŸ‡°", "Palau": "ğŸ‡µğŸ‡¼", "Palestine": "ğŸ‡µğŸ‡¸", "Panama": "ğŸ‡µğŸ‡¦", "Papua New Guinea": "ğŸ‡µğŸ‡¬", "Paraguay": "ğŸ‡µğŸ‡¾", "Peru": "ğŸ‡µğŸ‡ª", "Philippines": "ğŸ‡µğŸ‡­", "Poland": "ğŸ‡µğŸ‡±", "Portugal": "ğŸ‡µğŸ‡¹", "Qatar": "ğŸ‡¶ğŸ‡¦", "Romania": "ğŸ‡·ğŸ‡´", "Russia": "ğŸ‡·ğŸ‡º", "Rwanda": "ğŸ‡·ğŸ‡¼",
"Saint Kitts and Nevis": "ğŸ‡°ğŸ‡³", "Saint Lucia": "ğŸ‡±ğŸ‡¨", "Saint Vincent": "ğŸ‡»ğŸ‡¨", "Samoa": "ğŸ‡¼ğŸ‡¸", "San Marino": "ğŸ‡¸ğŸ‡²", "Sao Tome": "ğŸ‡¸ğŸ‡¹", "Saudi Arabia": "ğŸ‡¸ğŸ‡¦", "Senegal": "ğŸ‡¸ğŸ‡³", "Serbia": "ğŸ‡·ğŸ‡¸", "Seychelles": "ğŸ‡¸ğŸ‡¨", "Sierra Leone": "ğŸ‡¸ğŸ‡±", "Singapore": "ğŸ‡¸ğŸ‡¬", "Slovakia": "ğŸ‡¸ğŸ‡°", "Slovenia": "ğŸ‡¸ğŸ‡®", "Solomon Islands": "ğŸ‡¸ğŸ‡§", "Somalia": "ğŸ‡¸ğŸ‡´", "South Africa": "ğŸ‡¿ğŸ‡¦", "South Korea": "ğŸ‡°ğŸ‡·", "South Sudan": "ğŸ‡¸ğŸ‡¸", "Spain": "ğŸ‡ªğŸ‡¸", "Sri Lanka": "ğŸ‡±ğŸ‡°", "Sudan": "ğŸ‡¸ğŸ‡©", "Suriname": "ğŸ‡¸ğŸ‡·", "Sweden": "ğŸ‡¸ğŸ‡ª", "Switzerland": "ğŸ‡¨ğŸ‡­", "Syria": "ğŸ‡¸ğŸ‡¾",
"Taiwan": "ğŸ‡¹ğŸ‡¼", "Tajikistan": "ğŸ‡¹ğŸ‡¯", "Tanzania": "ğŸ‡¹ğŸ‡¿", "Thailand": "ğŸ‡¹ğŸ‡­", "Timor-Leste": "ğŸ‡¹ğŸ‡±", "Togo": "ğŸ‡¹ğŸ‡¬", "Tonga": "ğŸ‡¹ğŸ‡´", "Trinidad and Tobago": "ğŸ‡¹ğŸ‡¹", "Tunisia": "ğŸ‡¹ğŸ‡³", "Turkey": "ğŸ‡¹ğŸ‡·", "Turkmenistan": "ğŸ‡¹ğŸ‡²", "Tuvalu": "ğŸ‡¹ğŸ‡»",
"Uganda": "ğŸ‡ºğŸ‡¬", "Ukraine": "ğŸ‡ºğŸ‡¦", "UAE": "ğŸ‡¦ğŸ‡ª", "UK": "ğŸ‡¬ğŸ‡§", "USA": "ğŸ‡ºğŸ‡¸", "Uruguay": "ğŸ‡ºğŸ‡¾", "Uzbekistan": "ğŸ‡ºğŸ‡¿", "Vanuatu": "ğŸ‡»ğŸ‡º", "Vatican City": "ğŸ‡»ğŸ‡¦", "Venezuela": "ğŸ‡»ğŸ‡ª", "Vietnam": "ğŸ‡»ğŸ‡³", "Yemen": "ğŸ‡¾ğŸ‡ª", "Zambia": "ğŸ‡¿ğŸ‡²", "Zimbabwe": "ğŸ‡¿ğŸ‡¼"
}

def get_emoji(country_text):
    for c, e in COUNTRY_EMOJIS.items():
        if c.lower() in country_text.lower(): return f"{c} {e}"
    return country_text.split()[0] if country_text else "Unknown"

def solve_math(html):
    match = re.search(r'(\d+)\s*([+-])\s*(\d+)', html)
    if match:
        n1, op, n2 = int(match.group(1)), match.group(2), int(match.group(3))
        return str(n1 + n2 if op == '+' else n1 - n2)
    return None

def extract_otp(message):
    msg_str = str(message)
    matches = re.findall(r'\b\d{4,10}\b|\b\d{3,5}[-\s]\d{3,5}\b', msg_str)
    if matches:
        return matches[0].replace(" ", "").replace("-", "")
    match_fallback = re.search(r'\d{3,}', msg_str)
    return match_fallback.group(0) if match_fallback else "N/A"

def parse_env_headers():
    headers = {}
    action_url = None
    default_ua = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.0.0 Safari/537.36"
    headers["User-Agent"] = default_ua
    if not LOGIN_HEADERS_ENV: return headers, None
    clean_text = LOGIN_HEADERS_ENV.replace("\\\n", " ").replace("\\", " ")
    parts = re.split(r'\s-H\s|\s--header\s', clean_text)
    for part in parts:
        part = part.strip().strip("'").strip('"')
        if part.startswith("http") and "://" in part and not action_url:
            action_url = part.split()[0].strip("'").strip('"')
            continue
        if part.startswith("curl") or part.startswith("--") or part.startswith("-"): continue
        if ":" in part:
            try:
                key, val = part.split(":", 1)
                clean_val = re.split(r'\s--', val)[0].strip().strip("'").strip('"')
                headers[key.strip()] = clean_val
            except: pass
    return headers, action_url

# ============================================================
# ğŸš€ à¦‡à¦‰à¦¨à¦¿à¦­à¦¾à¦°à§à¦¸à¦¾à¦² à¦¸à§à¦¨à¦¾à¦‡à¦ªà¦¾à¦° à¦‡à¦à§à¦œà¦¿à¦¨ (Main Logic Kept Intact)
# ============================================================

def run_engine():
    global IS_FIRST_RUN
    
    while True:
        session = requests.Session()
        custom_headers, header_action_url = parse_env_headers()
        session.headers.update(custom_headers)
        
        session.headers.update({
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache',
            'Expires': '0'
        })
        
        try:
            # Login Process
            res_get = session.get(LOGIN_URL, timeout=15)
            soup = BeautifulSoup(res_get.text, 'html.parser')
            form = soup.find('form')
            final_action_url = header_action_url if header_action_url else (urljoin(LOGIN_URL, form.get('action')) if form else LOGIN_URL)

            payload = {}
            if form:
                inputs = form.find_all('input')
                for inp in inputs:
                    name, type_ = inp.get('name'), inp.get('type', 'text').lower()
                    if not name: continue
                    if type_ == 'password': payload[name] = PANEL_PASS
                    elif type_ == 'hidden': payload[name] = inp.get('value', '')
                    elif 'user' in name.lower() or 'email' in name.lower() or 'login' in name.lower():
                        if type_ != 'hidden': payload[name] = PANEL_USER
                    elif 'capt' in name.lower() or 'answer' in name.lower():
                        ans = solve_math(res_get.text)
                        if ans: payload[name] = ans

            if "Content-Type" not in session.headers:
                session.headers["Content-Type"] = "application/x-www-form-urlencoded"
            
            post_res = session.post(final_action_url, data=payload, timeout=15)

            if post_res.status_code == 200:
                send_admin_log("âœ… Login Successful! Collector Active.")
                
                while True:
                    try:
                        # Fetch Data
                        refresh_check = session.get(OTP_URL, timeout=10)
                        
                        if "login" in refresh_check.url.lower():
                            send_admin_log("âš ï¸ Session Expired! Re-logging...")
                            break 

                        raw_rows = []
                        ajax_link = None
                        ajax_patterns = [r'sAjaxSource":\s*"([^"]+)"', r'url:\s*[\'"]([^\'"]+res/data[^\'"]+)[\'"]']
                        for p in ajax_patterns:
                            m = re.search(p, refresh_check.text)
                            if m: ajax_link = urljoin(OTP_URL, m.group(1)); break

                        if ajax_link:
                            ajx_h = session.headers.copy()
                            ajx_h.update({'X-Requested-With': 'XMLHttpRequest', 'Referer': OTP_URL})
                            ajax_res = session.get(ajax_link, headers=ajx_h, timeout=10)
                            try:
                                jd = ajax_res.json()
                                raw_rows = jd.get('aaData', []) or jd.get('data', [])
                            except: pass
                        else:
                            soup_otp = BeautifulSoup(refresh_check.text, 'html.parser')
                            for tr in soup_otp.select("table tr")[1:]:
                                cols = [td.get_text(separator=" ", strip=True) for td in tr.find_all("td")]
                                if cols: raw_rows.append(cols)

                        # Reverse Logic
                        if raw_rows:
                            raw_rows = raw_rows[::-1]

                        target_rows = raw_rows[:100] if raw_rows else []
                        
                        for row in target_rows:
                            if len(row) > max(COL_MAP):
                                phone = str(row[COL_MAP[1]])
                                full_msg = str(row[COL_MAP[3]])
                                otp_code = extract_otp(full_msg)
                                cache_key = f"{phone}_{otp_code}_{full_msg}"
                                
                                with CACHE_LOCK:
                                    if cache_key not in PROCESSED_OTP_CACHE:
                                        PROCESSED_OTP_CACHE.add(cache_key)
                                        
                                        # Queue for Telegram
                                        country = get_emoji(str(row[COL_MAP[0]]))
                                        service = str(row[COL_MAP[2]])
                                        OTP_QUEUE.put((phone, country, service, otp_code, full_msg))
                        
                        time.sleep(CHECK_DELAY)
                    except Exception as e:
                        # Small errors won't break the session
                        time.sleep(CHECK_DELAY)
                        continue

            else:
                send_error_telegram("Login Failed", f"Status: {post_res.status_code}", "Engine")
                time.sleep(10)
        except Exception as e:
            time.sleep(5)
        finally:
            session.close()

# ============================================================
# ğŸ›¡ï¸ à¦¸à§à¦ªà¦¾à¦°à¦­à¦¾à¦‡à¦œà¦¾à¦° (Thread Monitor - Removed DB Logic)
# ============================================================

def thread_supervisor():
    while True:
        if threads_status["collector"] is None or not threads_status["collector"].is_alive():
            t = threading.Thread(target=run_engine, daemon=True)
            t.start()
            threads_status["collector"] = t
            send_admin_log("ğŸš€ Collector Thread Assigned.")

        if threads_status["sender"] is None or not threads_status["sender"].is_alive():
            t = threading.Thread(target=telegram_worker, daemon=True)
            t.start()
            threads_status["sender"] = t
            send_admin_log("ğŸš€ Sender Thread Assigned.")
        
        time.sleep(5)

# ======================
# ğŸ”„ à¦¸à§à¦Ÿà¦¾à¦°à§à¦Ÿà¦†à¦ª
# ======================

if __name__ == "__main__":
    threading.Thread(target=memory_cleaner, daemon=True).start()
    threading.Thread(target=thread_supervisor, daemon=True).start()
    
    port = int(os.environ.get("PORT", 5000))
    app.run(host='0.0.0.0', port=port)
